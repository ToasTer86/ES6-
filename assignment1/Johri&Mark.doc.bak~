<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE abiword PUBLIC "-//ABISOURCE//DTD AWML 1.0 Strict//EN" "http://www.abisource.com/awml.dtd">
<abiword template="false" xmlns:ct="http://www.abisource.com/changetracking.dtd" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:math="http://www.w3.org/1998/Math/MathML" xid-max="61" xmlns:dc="http://purl.org/dc/elements/1.1/" fileformat="1.1" xmlns:svg="http://www.w3.org/2000/svg" xmlns:awml="http://www.abisource.com/awml.dtd" xmlns="http://www.abisource.com/awml.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" version="3.0.0" xml:space="preserve" props="dom-dir:ltr; document-footnote-restart-section:0; document-endnote-type:numeric; document-endnote-place-enddoc:1; document-endnote-initial:1; lang:en-US; document-endnote-restart-section:0; document-footnote-restart-page:0; document-footnote-type:numeric; document-footnote-initial:1; document-endnote-place-endsection:0">
<!-- ======================================================================== -->
<!-- This file is an AbiWord document.                                        -->
<!-- AbiWord is a free, Open Source word processor.                           -->
<!-- More information about AbiWord is available at http://www.abisource.com/ -->
<!-- You should not edit this file by hand.                                   -->
<!-- ======================================================================== -->

<metadata>
<m key="abiword.date_last_changed">Tue Mar 15 09:52:19 2016
</m>
<m key="abiword.generator">AbiWord</m>
<m key="dc.date">Tue Mar 15 09:41:09 2016
</m>
<m key="dc.format">application/x-abiword</m>
</metadata>
<rdf>
</rdf>
<history version="2" edit-time="602868" last-saved="1458031939" uid="81717f20-e519-11e5-837a-a6ad8fe5d675">
<version id="2" started="1458031269" uid="39b75480-ea8b-11e5-837a-a6ad8fe5d675" auto="0" top-xid="45"/>
</history>
<styles>
<s type="P" name="Heading 1" basedon="Normal" followedby="Normal" props="keep-with-next:1; margin-top:22pt; font-weight:bold; margin-bottom:3pt; font-family:Liberation Sans; font-size:17pt"/>
<s type="P" name="Normal" basedon="" followedby="Current Settings" props="font-family:Liberation Serif; margin-top:0pt; font-variant:normal; margin-left:0pt; text-indent:0in; widows:2; font-style:normal; font-weight:normal; text-decoration:none; color:000000; line-height:1.0; text-align:left; margin-bottom:0pt; text-position:normal; margin-right:0pt; bgcolor:transparent; font-size:12pt; font-stretch:normal"/>
</styles>
<pagesize pagetype="A4" orientation="portrait" width="8.267717" height="11.692913" units="in" page-scale="1.000000"/>
<section xid="3">
<p style="Heading 1" xid="4"><c>Assignment 1 HW:<br/></c></p>
<p style="Normal" xid="2"><c props="font-weight:bold">Write a user space program to read the RTC, describe your findings:</c><c><br/><br/>First we tried a simple C++ program that uses the “ /dev/rtc/” directory. As expected this worked like charm, although this was not the goal of the assignment.<br/></c></p>
<p style="Normal" xid="27" props="text-align:left; dom-dir:ltr"><c>To read the RTC from userspace we have to use the CMOS register. Some google results later we arrived at the following page for the CMOS RTC addresses : http://stanislavs.org/helppc/cmos_ram.html and using this site we got some program examples: <br/>http://kernelx.weebly.com/cmos.html although this website was using DOS defined variables. Using the unix MANpages  we found out that  “ outportb == outb “ for linux users.</c></p>
<p style="Normal" xid="42" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="43" props="text-align:left; dom-dir:ltr"><c>It turned out that reading the CMOS is also not the way to go, although we did learn some interesting facts, now we know we should read the registers and write them into a variable and try to print them.</c></p>
<p style="Normal" xid="44" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="45" props="text-align:left; dom-dir:ltr"><c>To test this we are going to write a user space program that will write an </c><c props="font-weight:bold">int. </c><c props="font-weight:normal">We will print the memory address of this </c><c props="font-weight:bold">int </c><c props="font-weight:normal">and try to write to this memory address from a different user space program. The </c><c props="font-weight:bold">mmu </c><c props="font-weight:normal">should not allow us to do this and give us a segmention fault.</c></p>
<p style="Normal" xid="53" props="text-align:left; dom-dir:ltr"><c props="font-weight:normal"></c></p>
<p style="Normal" xid="46" props="text-align:left; dom-dir:ltr"><c props="font-weight:normal">For example our first user space program created and reserved the </c><c props="font-weight:bold">int </c><c props="font-weight:normal">on the following memory address : 0xbfa835cc. When we tried writing or even reading this address we of course received a segmention fault. <br/>Then as another test we tried the above in </c><c props="font-weight:bold">one</c><c props="font-weight:normal"> user space program, then we were able to create a </c><c props="font-weight:bold">int </c><c props="font-weight:normal">make a pointer towards it and increment it’s value with success.<br/><br/>Now we proved that the mmu will not allow us to manipulate memory in use by another program. Now we would like to read a physical memory address.</c></p>
<p style="Normal" xid="57" props="text-align:left; dom-dir:ltr"><c props="font-weight:normal">Trying to read out the memory address “ 0x400a8014“  on our laptop ofcourse returned us with another segmention fault, although the one thing we cannot verify right now if that address is really a physical on our laptop/pc.</c></p>
<p style="Normal" xid="59" props="text-align:left; dom-dir:ltr"><c props="font-weight:normal"></c></p>
<p style="Normal" xid="61" props="text-align:left; dom-dir:ltr"><c props="font-weight:normal">We checked the LCP3250 manual, on page 569 we found that the RTC up counter memory address 0x40024000, we shared this information with our co-students Sylvester &amp; Richel &amp; Menno.  Then we read out the value from this physical address, we had to write this is in a </c><c props="font-weight:bold">unsigned long long </c><c props="font-weight:normal">variable because of the size of the number stored in that register.<br/>Now we started brainstorming why we could read this address where we could not read another physical address or even random address. <br/>A logical explanation could be that the RTC is an entity that functions on its own, if we read the documentation our explanation could be confirmed. The RTC has its own 0.9 volt battery and </c></p>
<p style="Normal" xid="28" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="29" props="text-align:left; dom-dir:ltr"><c><pbr/></c></p>
<p style="Normal" xid="54" props="text-align:left; dom-dir:ltr"><c>Sources:</c></p>
<p style="Normal" xid="55" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="56" props="text-align:left; dom-dir:ltr"><c>http://stackoverflow.com/questions/3243610/difference-between-physical-addressing-and-virtual-addressing-concept<br/><br/>http://www.cs.utexas.edu/users/witchel/372/lectures/15.VirtualMemory.pdf</c></p>
</section>
</abiword>
